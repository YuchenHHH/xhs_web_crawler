# 图片重复检测功能

## 功能概述

在浏览笔记图片时，自动检测是否已经到达最后一张图片。如果发现连续两次截图相同（说明图片不再切换），自动结束当前笔记的浏览，提高效率。

## 工作原理

### 检测流程

```
进入笔记详情页
      ↓
  截图（第1张）
      ↓
  按右键 → 等待 → 截图（第2张）
      ↓
 对比截图1和截图2
      ↓
   相同？ ── 是 → 结束浏览（已到最后一张）
      ↓ 否
  保存截图2，继续按右键
      ↓
     重复...
```

### 代码位置

**文件**: [agent/click_nodes.py:229-269](agent/click_nodes.py#L229-L269)

**函数**: `_browse_images_with_arrow_keys`

## 实现细节

### 截图对比

```python
# 按右键后截图
current_screenshot = await page.screenshot(type="png")

# 对比截图是否相同（二进制对比）
if current_screenshot == prev_screenshot:
    print(f"检测到图片重复，已浏览完所有图片（共 {actual_browsed + 1} 张）")
    break

# 更新上一张截图
prev_screenshot = current_screenshot
```

### 二进制对比

- 使用 Playwright 的 `screenshot()` 返回的 PNG 字节数据
- 直接对比字节内容：`bytes1 == bytes2`
- 完全相同才判定为重复（像素级精确）

## 使用效果

### 场景 1: 笔记只有 3 张图片

```
设置: browse_images_count = 10

实际行为:
- 第1次按右键 → 截图不同 → 继续
- 第2次按右键 → 截图不同 → 继续
- 第3次按右键 → 截图相同 ✓ → 检测到重复，结束

日志输出:
📸 检测到图片重复，已浏览完所有图片（共 3 张）
```

**节省时间**: 原本需要按 10 次右键，现在只按 3 次

### 场景 2: 笔记有 8 张图片

```
设置: browse_images_count = 10

实际行为:
- 第1-7次按右键 → 截图不同 → 继续
- 第8次按右键 → 截图相同 ✓ → 检测到重复，结束

日志输出:
📸 检测到图片重复，已浏览完所有图片（共 8 张）
```

### 场景 3: 笔记有 15 张图片

```
设置: browse_images_count = 10

实际行为:
- 第1-10次按右键 → 截图不同 → 继续
- 达到设定次数 → 正常结束

日志输出:
📸 完成图片浏览（共按 10 次右键）
```

**说明**: 图片超过设定次数，正常结束，不会继续浏览

## 优势

### 1. 自动适配图片数量

✅ **智能结束**: 不需要手动设置每个笔记的图片数量
✅ **节省时间**: 图片少的笔记快速结束
✅ **避免空转**: 不会在最后一张图片上重复按右键

### 2. 提高效率

| 笔记类型 | 图片数量 | 设置次数 | 实际按键 | 节省时间 |
|---------|---------|---------|---------|---------|
| 单图笔记 | 1 | 10 | 1 | 90% |
| 少图笔记 | 3 | 10 | 3 | 70% |
| 中图笔记 | 6 | 10 | 6 | 40% |
| 多图笔记 | 12+ | 10 | 10 | 0% |

### 3. 模拟真实行为

真实用户浏览笔记时：
- 看到重复图片会停止浏览
- 不会在最后一张图片上反复点击

现在自动化行为更接近真人！

## 性能影响

### 截图开销

每次按右键后都会截图，会增加一些性能开销：

- **每次截图**: ~50-100ms
- **每个笔记**: 额外 0.5-1秒（取决于图片数量）

但因为提前结束浏览，总体上**节省时间**。

### 优化建议

如果性能是瓶颈，可以优化截图区域：

```python
# 只截图图片区域，不是整个页面
# 需要先定位图片容器
screenshot = await image_container.screenshot(type="png")
```

**当前实现**: 截取全页面（简单可靠）
**未来优化**: 可以改为只截取图片区域

## 配置参数

### browse_images_count

建议设置为稍大的值，让重复检测发挥作用：

```python
# 推荐设置
browse_images_count = 10  # 最多浏览10张，但遇到重复会提前结束

# 不推荐
browse_images_count = 3   # 太小，可能浏览不完
```

### 不同场景的建议值

| 场景 | 建议值 | 说明 |
|-----|-------|------|
| 快速测试 | 5 | 快速验证功能 |
| 一般使用 | 10 | 平衡效率和覆盖率 |
| 深度收集 | 15-20 | 确保浏览完整内容 |

## 日志示例

### 正常浏览完整

```
🎯 点击第 1/10 个元素: 标记ID=1
   - 📌 使用 SoM ElementHandle 直接点击
   - ✅ 已执行元素点击（SoM 方案）
   - 📸 进入详情页，开始浏览图片（按10次右键）...
   - 📸 检测到图片重复，已浏览完所有图片（共 3 张）
   - ✅ 图片浏览完成
```

### 达到设定次数

```
🎯 点击第 2/10 个元素: 标记ID=2
   - 📌 使用 SoM ElementHandle 直接点击
   - ✅ 已执行元素点击（SoM 方案）
   - 📸 进入详情页，开始浏览图片（按10次右键）...
   - 📸 完成图片浏览（共按 10 次右键）
   - ✅ 图片浏览完成
```

## 边缘情况处理

### 1. 图片加载慢

**问题**: 图片还在加载，截图可能相同

**解决**: 每次按右键后等待 0.4-0.8 秒，给图片足够加载时间

```python
await page.keyboard.press("ArrowRight")
await asyncio.sleep(random.uniform(0.4, 0.8))  # 等待图片加载
current_screenshot = await page.screenshot(type="png")
```

### 2. 视频笔记

**问题**: 视频笔记按右键可能无效

**行为**: 截图会持续相同，第一次就会检测到重复

**日志**:
```
📸 检测到图片重复，已浏览完所有图片（共 1 张）
```

这是正确的行为，因为视频笔记确实只有 1 个视图。

### 3. 轮播动画

**问题**: 如果笔记有轮播动画或元素变化

**影响**: 可能导致误判（截图不同但实际是同一张图）

**概率**: 极低，小红书笔记图片通常是静态的

## 禁用重复检测

如果想禁用重复检测，恢复到简单的循环按键：

```python
# agent/click_nodes.py
async def _browse_images_with_arrow_keys(page: Page, arrow_count: int = 5):
    try:
        await asyncio.sleep(0.5)

        for i in range(arrow_count):
            await page.keyboard.press("ArrowRight")
            await asyncio.sleep(random.uniform(0.4, 0.8))

        print(f"   - 📸 完成图片浏览（共按 {arrow_count} 次右键）")
    except Exception as e:
        print(f"   - ⚠️ 浏览图片时出错: {e}")
```

## 总结

图片重复检测功能通过对比连续截图，自动识别何时到达最后一张图片，实现了：

✅ **智能结束**: 自动适配不同笔记的图片数量
✅ **提高效率**: 避免在最后一张图片上空转
✅ **模拟真人**: 更接近真实用户的浏览行为
✅ **节省时间**: 单图笔记可节省 90% 的浏览时间

结合内容过滤功能，现在可以实现高效、精准、智能的小红书笔记数据收集！
